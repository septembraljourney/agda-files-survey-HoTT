Import
```agda
{-#  OPTIONS --rewriting --without-K  #-}

module thesis-4-hit where

open import thesis-4-ua public
```

We defined inductive types which are 'freely generated by some points'
Now we declare the existence of some types which is
'freely generated by some points and higher paths'.
Such a type is called a higher inductive type.
HoTT in Agda doesn't support automated application of inference rules of higher inductive types,
hence we have to directly handle elimination rules by our hands
and manually append some judgemental equalities corresponding to computation rules.

First declare the following command in Agda,
which will allow us to add some judgemental equalities.
```agda
{-# BUILTIN REWRITE _ï¼_ #-}
```



Pushout
```agda
postulate
  pushout : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚) â†’ type (â„“ âŠ” â„“' âŠ” â„“'')

postulate
  inâ‚ : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''} {fâ‚ : X â†’ Aâ‚} {fâ‚‚ : X â†’ Aâ‚‚}
      â†’ Aâ‚ â†’ pushout fâ‚ fâ‚‚

  inâ‚‚ : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''} {fâ‚ : X â†’ Aâ‚} {fâ‚‚ : X â†’ Aâ‚‚}
      â†’ Aâ‚‚ â†’ pushout fâ‚ fâ‚‚

  glue : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''} {fâ‚ : X â†’ Aâ‚} {fâ‚‚ : X â†’ Aâ‚‚}
      â†’ (x : X) â†’ inâ‚ {fâ‚ = fâ‚} {fâ‚‚ = fâ‚‚} (fâ‚ x) ï¼ inâ‚‚ (fâ‚‚ x)

postulate
  pushout-elim : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ (ğ“Ÿ : pushout fâ‚ fâ‚‚ â†’ type â„“''')
          â†’ (Ï†â‚ : Î  (ğ“Ÿ âˆ˜ inâ‚)) â†’ (Ï†â‚‚ : Î  (ğ“Ÿ âˆ˜ inâ‚‚))
          â†’ (I : (x : X) â†’ (Ï†â‚ (fâ‚ x)) ï¼â†‘ Ï†â‚‚ (fâ‚‚ x) [ glue x ]over ğ“Ÿ )
          â†’ Î  ğ“Ÿ
```
Above code formulate formation and elimination rules of pushout.
Now we use REWRITE command to append corresponding computation rules:
```agda
postulate
  pushout-comp-1 : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ (ğ“Ÿ : pushout fâ‚ fâ‚‚ â†’ type â„“''')
          â†’ (Ï†â‚ : Î  (ğ“Ÿ âˆ˜ inâ‚)) â†’ (Ï†â‚‚ : Î  (ğ“Ÿ âˆ˜ inâ‚‚))
          â†’ (I : (x : X) â†’ (Ï†â‚ (fâ‚ x)) ï¼â†‘ Ï†â‚‚ (fâ‚‚ x) [ glue x ]over ğ“Ÿ )
          â†’ (a1 : Aâ‚)
          â†’ (pushout-elim fâ‚ fâ‚‚ ğ“Ÿ Ï†â‚ Ï†â‚‚ I) (inâ‚ a1) ï¼ (Ï†â‚ a1)

  pushout-comp-2 : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ (ğ“Ÿ : pushout fâ‚ fâ‚‚ â†’ type â„“''')
          â†’ (Ï†â‚ : Î  (ğ“Ÿ âˆ˜ inâ‚)) â†’ (Ï†â‚‚ : Î  (ğ“Ÿ âˆ˜ inâ‚‚))
          â†’ (I : (x : X) â†’ (Ï†â‚ (fâ‚ x)) ï¼â†‘ Ï†â‚‚ (fâ‚‚ x) [ glue x ]over ğ“Ÿ )
          â†’ (a2 : Aâ‚‚)
          â†’ (pushout-elim fâ‚ fâ‚‚ ğ“Ÿ Ï†â‚ Ï†â‚‚ I) (inâ‚‚ a2) ï¼ (Ï†â‚‚ a2)

{-# REWRITE pushout-comp-1 #-}
{-# REWRITE pushout-comp-2 #-}
```

The computation rule for path is given as follows:
(We DON'T assume the equality holds judgementally for path cases)
```agda
postulate
  pushout-comp-glue : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ (ğ“Ÿ : pushout fâ‚ fâ‚‚ â†’ type â„“''')
          â†’ (Ï†â‚ : Î  (ğ“Ÿ âˆ˜ inâ‚)) â†’ (Ï†â‚‚ : Î  (ğ“Ÿ âˆ˜ inâ‚‚))
          â†’ (I : (x : X) â†’ (Ï†â‚ (fâ‚ x)) ï¼â†‘ Ï†â‚‚ (fâ‚‚ x) [ glue x ]over ğ“Ÿ )
          â†’ (x : X) â†’ apd (pushout-elim fâ‚ fâ‚‚ ğ“Ÿ Ï†â‚ Ï†â‚‚ I) (glue x) ï¼ I x
```


For the non-dependent case, we induce the following recursion rule:
```agda
pushout-rec : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ (Y : type â„“''')
          â†’ (Ï†â‚ : Aâ‚ â†’ Y) â†’ (Ï†â‚‚ : Aâ‚‚ â†’ Y)
          â†’ (I : (x : X) â†’ (Ï†â‚ (fâ‚ x)) ï¼ Ï†â‚‚ (fâ‚‚ x) )
          â†’ (pushout fâ‚ fâ‚‚) â†’ Y
pushout-rec {X = X} fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ I
  = pushout-elim fâ‚ fâ‚‚ (Î» _ â†’ Y) Ï†â‚ Ï†â‚‚ ((Î» x â†’ tr-const (glue x) (Ï†â‚ (fâ‚ x))) âˆ™â‚• I)

pushout-rec-comp-1 : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ (Y : type â„“''')
          â†’ (Ï†â‚ : Aâ‚ â†’ Y) â†’ (Ï†â‚‚ : Aâ‚‚ â†’ Y)
          â†’ (I : (x : X) â†’ (Ï†â‚ (fâ‚ x)) ï¼ Ï†â‚‚ (fâ‚‚ x) )
          â†’ (a1 : Aâ‚) â†’ (pushout-rec fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ I) (inâ‚ a1) ï¼ Ï†â‚ a1
pushout-rec-comp-1 fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ I a1 = refl _

pushout-rec-comp-2 : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ (Y : type â„“''')
          â†’ (Ï†â‚ : Aâ‚ â†’ Y) â†’ (Ï†â‚‚ : Aâ‚‚ â†’ Y)
          â†’ (I : (x : X) â†’ (Ï†â‚ (fâ‚ x)) ï¼ Ï†â‚‚ (fâ‚‚ x) )
          â†’ (a2 : Aâ‚‚) â†’ (pushout-rec fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ I) (inâ‚‚ a2) ï¼ Ï†â‚‚ a2
pushout-rec-comp-2 fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ I a2 = refl _

pushout-rec-comp-glue : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ (Y : type â„“''')
          â†’ (Ï†â‚ : Aâ‚ â†’ Y) â†’ (Ï†â‚‚ : Aâ‚‚ â†’ Y)
          â†’ (I : (x : X) â†’ (Ï†â‚ (fâ‚ x)) ï¼ Ï†â‚‚ (fâ‚‚ x) )
          â†’ (x : X) â†’ ap (pushout-rec fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ I) (glue x) ï¼ I x
-- type checks by the above judgemental equality (refl) !
pushout-rec-comp-glue {X = X} fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ I x
  = ap s (glue x)                ï¼âŸ¨ ap (Î» - â†’ - âˆ™ ap s (glue x)) (sym (âˆ™-sym-l q)) âŸ©
    q â»Â¹ âˆ™ q âˆ™ ap s (glue x)     ï¼âŸ¨ âˆ™-assoc (q â»Â¹) q (ap s (glue x)) âŸ©
    q â»Â¹ âˆ™ (q âˆ™ ap s (glue x)) ï¼âŸ¨ ap (Î» - â†’ q â»Â¹ âˆ™ -) (sym (apd-const s (glue x))) âŸ©
    q â»Â¹ âˆ™ apd s (glue x) ï¼âŸ¨ ap (Î» - â†’ q â»Â¹ âˆ™ -) (P x) âŸ©
    q â»Â¹ âˆ™ (q âˆ™ (I x)) ï¼âŸ¨ sym (âˆ™-assoc (q â»Â¹) q (I x)) âŸ©
    q â»Â¹ âˆ™ q âˆ™ I x ï¼âŸ¨ ap (Î» - â†’ - âˆ™ I x) (âˆ™-sym-l q) âŸ©
    I x âˆ
  where
  s = pushout-rec fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ I
  P :  (xâ‚ : X) â†’
        apd s (glue xâ‚) ï¼ ((Î» t â†’ tr-const (glue t) (Ï†â‚ (fâ‚ t))) âˆ™â‚• I) xâ‚
  P = pushout-comp-glue fâ‚ fâ‚‚ (Î» - â†’ Y) Ï†â‚ Ï†â‚‚ ((Î» x â†’ tr-const (glue x) (Ï†â‚ (fâ‚ x))) âˆ™â‚• I)
  q = tr-const (glue x) (s (inâ‚ (fâ‚ x)))
  -- apd-const s (glue x) : apd s (glue x) ï¼ q âˆ™ ap s (glue x)
  -- P x : apd s (glue x) ï¼ tr-const (glue x) (Ï†â‚ (fâ‚ x)) âˆ™ I x
  -- ê·¸ëŸ°ë° s âˆ˜ inâ‚ â‰¡ Ï†â‚  by computation rule
  -- P x : apd s (glue x) ï¼ q âˆ™ I x

    -- pushout-rec ì„ ì •ì˜í•  ë•Œ ë„£ì€ input ê·¸ëŒ€ë¡œì„.
```

Now we show that the defined type becomes
the colimit of the prepushout diagram A â† X â†’ B
"up to homotopy"

First we define a square diagram commute up to homotopy:
```agda
square :  {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''} {Y : type â„“'''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚) (Ï†â‚ : Aâ‚ â†’ Y) (Ï†â‚‚ : Aâ‚‚ â†’ Y)
          â†’ type (â„“ âŠ” â„“''')
square fâ‚ fâ‚‚ Ï†â‚ Ï†â‚‚ = Ï†â‚ âˆ˜ fâ‚ âˆ¼ Ï†â‚‚ âˆ˜ fâ‚‚
```

Pushout with fâ‚ and fâ‚‚ constitutes a square with inâ‚ and inâ‚‚ by glue:
```agda
pushout-square :  {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚)
          â†’ square fâ‚ fâ‚‚ (inâ‚ {fâ‚ = fâ‚} {fâ‚‚ = fâ‚‚}) inâ‚‚
pushout-square fâ‚ fâ‚‚ = glue
```

One can show that it is "up to homotopy" initial among (square fâ‚ fâ‚‚).
That is, if we have a square "H : square fâ‚ fâ‚‚ g h" with Y as codomain of g,
there exists (up to homotopy) unique function k : (pushout f g) â†’ Y
such that suitable commutances hold.
From this one can easily prove that pushout is up to type equivalence unique,
resulting in pushouts with the same base are equivalent.

```agda
pushout-âˆƒ : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''} {Y : type â„“'''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚) (Ï†â‚ : Aâ‚ â†’ Y) (Ï†â‚‚ : Aâ‚‚ â†’ Y)
          â†’ square fâ‚ fâ‚‚ Ï†â‚ Ï†â‚‚
          â†’ (pushout fâ‚ fâ‚‚) â†’ Y
pushout-âˆƒ {Y = Y} fâ‚ fâ‚‚ Ï†â‚ Ï†â‚‚ H = pushout-rec fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ H

-- The above-constructed function s satisfies the homotopy
-- apâ‚› âˆ˜ glue â‰¡ s âˆ˜â‚— glue âˆ¼ H
-- by pushout-comp-path.

ASSOC' :  {X : type â„“} {x1 x2 x3 x4 x5 x6 : X}
      â†’ (p1 : x1 ï¼ x2) (p2 : x2 ï¼ x3) (p3 : x3 ï¼ x4) (p4 : x4 ï¼ x5) (p5 : x5 ï¼ x6)
      â†’ p1 âˆ™ p2 âˆ™ (p3 âˆ™ p4 âˆ™ p5) ï¼ p1 âˆ™ (p2 âˆ™ p3 âˆ™ p4) âˆ™ p5
ASSOC' (refl _) (refl _) p3 p4 p5 = refl _


pushout-! : {X : type â„“} {Aâ‚ : type â„“'} {Aâ‚‚ : type â„“''} {Y : type â„“'''}
          â†’ (fâ‚ : X â†’ Aâ‚) (fâ‚‚ : X â†’ Aâ‚‚) (Ï†â‚ : Aâ‚ â†’ Y) (Ï†â‚‚ : Aâ‚‚ â†’ Y)
          â†’ (H : square fâ‚ fâ‚‚ Ï†â‚ Ï†â‚‚)
          â†’ (Î± : (pushout fâ‚ fâ‚‚) â†’ Y)
          â†’ (Kâ‚ : Ï†â‚ âˆ¼ Î± âˆ˜ inâ‚) â†’ (Kâ‚‚ : Î± âˆ˜ inâ‚‚ âˆ¼ Ï†â‚‚)
          â†’ (Kâ‚ âˆ˜áµ£ fâ‚) âˆ™â‚• (Î± âˆ˜â‚— (glue {fâ‚ = fâ‚} {fâ‚‚ = fâ‚‚})) âˆ™â‚• (Kâ‚‚ âˆ˜áµ£ fâ‚‚) âˆ¼ H
          â†’ Î± âˆ¼ (pushout-âˆƒ fâ‚ fâ‚‚ Ï†â‚ Ï†â‚‚ H)
pushout-! {X = X} {Y = Y} fâ‚ fâ‚‚ Ï†â‚ Ï†â‚‚ H Î± Kâ‚ Kâ‚‚ COH
  = pushout-elim fâ‚ fâ‚‚ ğ“Ÿ
                 (ht-sym Kâ‚)
                 Kâ‚‚
                 G
  where
  Ï† = pushout-âˆƒ fâ‚ fâ‚‚ Ï†â‚ Ï†â‚‚ H
  ğ“Ÿ = (Î» z â†’ Î± z ï¼ Ï† z)
  G : (x : X) â†’ ((ht-sym Kâ‚) (fâ‚ x)) ï¼â†‘ (Kâ‚‚ (fâ‚‚ x)) [ glue x ]over ğ“Ÿ
  G x = tr (Î» z â†’ Î± z ï¼ Ï† z) (glue x) ((Kâ‚ (fâ‚ x)) â»Â¹) ï¼âŸ¨ tr-path-btwmaps Î± Ï† (glue x) ((Kâ‚ (fâ‚ x)) â»Â¹) âŸ©
        ap Î± (glue x) â»Â¹ âˆ™ Kâ‚ (fâ‚ x) â»Â¹ âˆ™ ap Ï† (glue x) ï¼âŸ¨ ap (Î» - â†’ ap Î± (glue x) â»Â¹ âˆ™ Kâ‚ (fâ‚ x) â»Â¹ âˆ™ -) Ï†-comp âŸ©
        ap Î± (glue x) â»Â¹ âˆ™ Kâ‚ (fâ‚ x) â»Â¹ âˆ™ H x ï¼âŸ¨ ap (Î» - â†’ ap Î± (glue x) â»Â¹ âˆ™ Kâ‚ (fâ‚ x) â»Â¹ âˆ™ -) (sym (COH x)) âŸ©
        ap Î± (glue x) â»Â¹ âˆ™ Kâ‚ (fâ‚ x) â»Â¹ âˆ™ (Kâ‚ (fâ‚ x) âˆ™ ap Î± (glue x) âˆ™ Kâ‚‚ (fâ‚‚ x))
             ï¼âŸ¨ ASSOC' (ap Î± (glue x) â»Â¹) (Kâ‚ (fâ‚ x) â»Â¹) (Kâ‚ (fâ‚ x)) (ap Î± (glue x)) (Kâ‚‚ (fâ‚‚ x)) âŸ©
        ap Î± (glue x) â»Â¹ âˆ™ (Kâ‚ (fâ‚ x) â»Â¹ âˆ™ Kâ‚ (fâ‚ x) âˆ™ ap Î± (glue x)) âˆ™ Kâ‚‚ (fâ‚‚ x)
             ï¼âŸ¨ ap (Î» - â†’  ap Î± (glue x) â»Â¹ âˆ™ ( - âˆ™ ap Î± (glue x)) âˆ™ Kâ‚‚ (fâ‚‚ x)) (âˆ™-sym-l (Kâ‚ (fâ‚ x))) âŸ©
        ap Î± (glue x) â»Â¹ âˆ™ ap Î± (glue x) âˆ™ Kâ‚‚ (fâ‚‚ x) ï¼âŸ¨ ap (Î» - â†’ - âˆ™ Kâ‚‚ (fâ‚‚ x)) (âˆ™-sym-l (ap Î± (glue x))) âŸ©
        Kâ‚‚ (fâ‚‚ x) âˆ
    where
    Ï†-comp : ap Ï† (glue x) ï¼ H x
    Ï†-comp = pushout-rec-comp-glue fâ‚ fâ‚‚ Y Ï†â‚ Ï†â‚‚ H x
```
COH x : Kâ‚ (fâ‚ x) âˆ™ ap Î± (glue x) âˆ™ Kâ‚‚ (fâ‚‚ x) ï¼ H x

âˆ´ The HIT pushout defines the initial cocone up to natural isomorphism.
We call the related object as hotomopy colimit. For the prepushout diagram, we call it homotopy pushout.




Suspension, spheres and the circle

Suspension and inductively defined spheres
```agda
ğšº : (X : type â„“) â†’ type â„“
ğšº X = pushout {X = X} constâ‹† constâ‹†  --BGS

S^_ : â„• â†’ ğ“¤
S^ 0 = ğŸš
S^ suc n = ğšº (S^ n)


-- notation for S^ 1
north south : S^ 1
north = inâ‚ â‹†
south = inâ‚‚ â‹†

west east : north ï¼ south
west = glue â‚
east = glue â‚‚
```



Another formulation of the circle- SÂ¹
```agda
postulate
  SÂ¹ : ğ“¤
  base : SÂ¹
  loop : base ï¼ base

postulate
  SÂ¹elim : (ğ“Ÿ : SÂ¹ â†’ type â„“) (x : ğ“Ÿ base) (â„“ : x ï¼â†‘ x  [ loop ]over ğ“Ÿ )
        â†’ (z : SÂ¹) â†’ ğ“Ÿ z

postulate
  SÂ¹comp-base :  (ğ“Ÿ : SÂ¹ â†’ type â„“) (x : ğ“Ÿ base) (â„“ : x ï¼â†‘ x  [ loop ]over ğ“Ÿ)
             â†’  ((SÂ¹elim ğ“Ÿ x â„“) base) ï¼ x
{-#  REWRITE SÂ¹comp-base  #-}

postulate
  SÂ¹comp-loop :  (ğ“Ÿ : SÂ¹ â†’ type â„“) (x : ğ“Ÿ base) (â„“ : x ï¼â†‘ x [ loop ]over ğ“Ÿ)
             â†’ apd (SÂ¹elim ğ“Ÿ x â„“) loop ï¼ â„“
```

non-dependent case follows from the above axioms as:
```agda
SÂ¹rec : (A : type â„“) (a : A) (p : a ï¼ a)
      â†’ SÂ¹ â†’ A
SÂ¹rec A a p = SÂ¹elim (\ - â†’ A) a (tr-const loop a âˆ™ p)


SÂ¹rec-comp-base : (A : type â„“) (a : A) (p : a ï¼ a)
           â†’ ((SÂ¹rec A a p) base) ï¼ a
SÂ¹rec-comp-base  A a p  = refl a   --judgementally holds by SÂ¹comp-base


SÂ¹rec-comp-loop : (A : type â„“) (a : A) (p : a ï¼ a)
           â†’ ap (SÂ¹rec A a p) loop ï¼ p
SÂ¹rec-comp-loop  A a p
  = ap f loop   ï¼âŸ¨ ap (Î» - â†’ - âˆ™ (ap f loop)) (sym (âˆ™-sym-l q)) âŸ©
    (q â»Â¹ âˆ™ q) âˆ™ (ap f loop)   ï¼âŸ¨ âˆ™-assoc (q â»Â¹) q (ap f loop) âŸ©
    q â»Â¹ âˆ™ (q âˆ™ ap f loop)   ï¼âŸ¨ ap (Î» - â†’ q â»Â¹ âˆ™ -) (sym (apd-const f loop)) âŸ©
    q â»Â¹ âˆ™ (apd f loop)  ï¼âŸ¨ ap (Î» - â†’ q â»Â¹ âˆ™ -) (SÂ¹comp-loop (Î» - â†’ A) a (q âˆ™ p)) âŸ©
    q â»Â¹ âˆ™ (q âˆ™ p)   ï¼âŸ¨ sym (âˆ™-assoc (q â»Â¹) q p) âŸ©
    q â»Â¹ âˆ™ q âˆ™ p   ï¼âŸ¨ ap (Î» - â†’ - âˆ™ p) (âˆ™-sym-l q) âŸ©
    p âˆ
  where
  f = SÂ¹rec A a p
  q = tr-const loop a

--apd-const f loop : (apd f loop) ï¼ â„“ âˆ™ (ap f loop) (â‰¡ a ï¼ a [loop]over (constfamily A))
--SÂ¹comp-loop (Î» - â†’ A) a (â„“ âˆ™ p) : (apd f loop) ï¼ â„“ âˆ™ p

SÂ¹rec-loop-sym :  (A : type â„“) (a : A) (p : a ï¼ a)
      â†’ ap (SÂ¹rec A a p) (loop â»Â¹) ï¼ p â»Â¹
SÂ¹rec-loop-sym A a p
  = ap f (sym loop)  ï¼âŸ¨ ap-sym f loop âŸ©
    sym (ap f loop)  ï¼âŸ¨ ap (\ - â†’ sym -) (SÂ¹rec-comp-loop A a p) âŸ©
    sym p   âˆ
  where
  f = SÂ¹rec A a p
```



The circle defined by pushout
(the full subcategory of the topological circle's fundamental groupoid
generated by the north pole and the south pole)
and the circle defined by another higher inductive type
(the loop space of the topological circle) is isomorphic
```agda

ğŸštoloopspace : ğŸš â†’ base ï¼ base
ğŸštoloopspace â‚ = loop
ğŸštoloopspace â‚‚ = refl base

toSÂ¹ : (S^ 1) â†’ SÂ¹
toSÂ¹ = pushout-rec   constâ‹† constâ‹†
        SÂ¹
        (Î» - â†’ base)
        (Î» - â†’ base)
        ğŸštoloopspace

fromSÂ¹ : SÂ¹ â†’ (S^ 1)
fromSÂ¹ = SÂ¹rec
        (S^ 1)
        north
        (west âˆ™ (east â»Â¹))



app-fromSÂ¹-loop :  ap (fromSÂ¹) loop ï¼ west âˆ™ east â»Â¹
app-fromSÂ¹-loop = SÂ¹rec-comp-loop (S^ 1) north (west âˆ™ (east â»Â¹))

app-toSÂ¹ : (x : ğŸš) â†’ ap toSÂ¹ (glue x) ï¼ ğŸštoloopspace x
app-toSÂ¹ = pushout-rec-comp-glue constâ‹† constâ‹† SÂ¹ (Î» - â†’ base) (Î» - â†’ base) ğŸštoloopspace
app-toSÂ¹-west : ap toSÂ¹ west ï¼ loop
app-toSÂ¹-west = app-toSÂ¹ â‚
app-toSÂ¹-east : ap toSÂ¹ east ï¼ refl base
app-toSÂ¹-east = app-toSÂ¹ â‚‚


tofrom : toSÂ¹ âˆ˜ fromSÂ¹ âˆ¼ id
tofrom = SÂ¹elim
           ğ“Ÿ
           loop
           looploop-over-loop
    where
    ğ“Ÿ = Î» z â†’ (toSÂ¹ âˆ˜ fromSÂ¹) z ï¼ id z
    looploop-over-loop : loop ï¼â†‘ loop [ loop ]over ğ“Ÿ
    looploop-over-loop
      = tr ğ“Ÿ loop loop ï¼âŸ¨ tr-path-btwmaps (toSÂ¹ âˆ˜ fromSÂ¹) id loop loop âŸ©
       (ap (toSÂ¹ âˆ˜ fromSÂ¹) loop) â»Â¹ âˆ™ loop âˆ™ ap id loop ï¼âŸ¨ ap (Î» - â†’ ap (toSÂ¹ âˆ˜ fromSÂ¹) loop â»Â¹ âˆ™ loop âˆ™ -) (ap-id loop) âŸ©
       (ap (toSÂ¹ âˆ˜ fromSÂ¹) loop) â»Â¹ âˆ™ loop âˆ™ loop ï¼âŸ¨ ap (Î» - â†’ (-) â»Â¹ âˆ™ loop âˆ™ loop) (ap-âˆ˜ toSÂ¹ fromSÂ¹ loop) âŸ©
       (ap toSÂ¹ (ap fromSÂ¹ loop)) â»Â¹ âˆ™ loop âˆ™ loop ï¼âŸ¨ ap (Î» - â†’ (ap toSÂ¹ -) â»Â¹ âˆ™ loop âˆ™ loop) app-fromSÂ¹-loop âŸ©
       (ap toSÂ¹ (west âˆ™ east â»Â¹)) â»Â¹ âˆ™ loop âˆ™ loop ï¼âŸ¨ ap (Î» - â†’ - âˆ™ loop âˆ™ loop) (sym (ap-sym toSÂ¹ (west âˆ™ east â»Â¹))) âŸ©
       (ap toSÂ¹ ((west âˆ™ east â»Â¹) â»Â¹)) âˆ™ loop âˆ™ loop ï¼âŸ¨ ap (Î» - â†’ ap toSÂ¹ - âˆ™ loop âˆ™ loop) (symâˆ™ west (sym east)) âŸ©
       ap toSÂ¹ (sym (sym east) âˆ™ west â»Â¹) âˆ™ loop âˆ™ loop ï¼âŸ¨ ap (Î» - â†’ ap toSÂ¹ (- âˆ™ west â»Â¹) âˆ™ loop âˆ™ loop) (symÂ²~id east) âŸ©
       ap toSÂ¹ (east âˆ™ west â»Â¹) âˆ™ loop âˆ™ loop ï¼âŸ¨ ap (Î» - â†’ - âˆ™ loop âˆ™ loop) (ap-âˆ™ toSÂ¹ east (west â»Â¹)) âŸ©
       (ap toSÂ¹ east) âˆ™ (ap toSÂ¹ (west â»Â¹)) âˆ™ loop âˆ™ loop
                ï¼âŸ¨ ap (Î» - â†’ - âˆ™ loop âˆ™ loop) (apâ‚‚ (Î» - ~ â†’ - âˆ™ ~) app-toSÂ¹-east (ap-sym toSÂ¹ west)) âŸ©
       (ap toSÂ¹ west) â»Â¹ âˆ™ loop âˆ™ loop ï¼âŸ¨ ap (Î» - â†’ (-) â»Â¹ âˆ™ loop âˆ™ loop) app-toSÂ¹-west âŸ©
       loop â»Â¹ âˆ™ loop âˆ™ loop ï¼âŸ¨ ap (Î» - â†’ - âˆ™ loop) (âˆ™-sym-l loop) âŸ©
       loop âˆ



fromto : fromSÂ¹ âˆ˜ toSÂ¹ âˆ¼ id
fromto = pushout-elim  constâ‹† constâ‹†
           ğ“Ÿ
           (Î» {â‹† â†’ refl north})
           (Î» {â‹† â†’ east})
           refltoeast-over-glue
  where
  ğ“Ÿ = (Î» z â†’ (fromSÂ¹ âˆ˜ toSÂ¹) z ï¼ id z)
  refltoeast-over-glue : (x : ğŸš) â†’ (refl north) ï¼â†‘ east [ glue x ]over ğ“Ÿ
  refltoeast-over-glue â‚
    = tr ğ“Ÿ west (refl north) ï¼âŸ¨ tr-path-btwmaps (fromSÂ¹ âˆ˜ toSÂ¹) id west (refl north)  âŸ©
      (ap (fromSÂ¹ âˆ˜ toSÂ¹) west)â»Â¹ âˆ™ (refl north) âˆ™ (ap id west) ï¼âŸ¨ âˆ™-assoc ((ap (fromSÂ¹ âˆ˜ toSÂ¹) west)â»Â¹) (refl north) (ap id west) âŸ©
      (ap (fromSÂ¹ âˆ˜ toSÂ¹) west)â»Â¹ âˆ™ ap id west ï¼âŸ¨ ap (Î» - â†’ (ap (fromSÂ¹ âˆ˜ toSÂ¹) west)â»Â¹ âˆ™ -) (ap-id west) âŸ©
      (ap (fromSÂ¹ âˆ˜ toSÂ¹) west)â»Â¹ âˆ™ west ï¼âŸ¨ ap (Î» - â†’ (-)â»Â¹ âˆ™ west) (ap-âˆ˜ fromSÂ¹ toSÂ¹ west) âŸ©
      (ap fromSÂ¹ (ap toSÂ¹ west))â»Â¹ âˆ™ west ï¼âŸ¨ ap (Î» - â†’ (ap fromSÂ¹ -) â»Â¹ âˆ™ west) app-toSÂ¹-west âŸ©
      (ap fromSÂ¹ loop)â»Â¹ âˆ™ west ï¼âŸ¨ ap (Î» - â†’ - â»Â¹ âˆ™ west) app-fromSÂ¹-loop âŸ©
      (west âˆ™ (east)â»Â¹)â»Â¹ âˆ™ west ï¼âŸ¨ ap (Î» - â†’ - âˆ™ west) (symâˆ™ west (east â»Â¹)) âŸ©
      (east â»Â¹)â»Â¹ âˆ™ west â»Â¹ âˆ™ west ï¼âŸ¨ ap (Î» - â†’ - âˆ™ west â»Â¹ âˆ™ west) (symÂ²~id east) âˆ™ (âˆ™-assoc east (west â»Â¹) west) âŸ©
      east âˆ™ (west â»Â¹ âˆ™ west) ï¼âŸ¨ ap (Î» - â†’ east âˆ™ -) (âˆ™-sym-l west) âˆ™ (âˆ™-refl-r east) âŸ©
      east âˆ

  refltoeast-over-glue â‚‚
    = tr ğ“Ÿ east (refl north) ï¼âŸ¨ tr-path-btwmaps (fromSÂ¹ âˆ˜ toSÂ¹) id east (refl north) âŸ©
      (ap (fromSÂ¹ âˆ˜ toSÂ¹) east)â»Â¹ âˆ™ refl north âˆ™ ap id east ï¼âŸ¨ âˆ™-assoc ((ap (fromSÂ¹ âˆ˜ toSÂ¹) east)â»Â¹) (refl north) (ap id east) âŸ©
      (ap (fromSÂ¹ âˆ˜ toSÂ¹) east)â»Â¹ âˆ™ ap id east ï¼âŸ¨ ap (Î» - â†’ (ap (fromSÂ¹ âˆ˜ toSÂ¹) east)â»Â¹ âˆ™ -) (ap-id east) âŸ©
      (ap (fromSÂ¹ âˆ˜ toSÂ¹) east)â»Â¹ âˆ™ east ï¼âŸ¨ ap (Î» - â†’ (-)â»Â¹ âˆ™ east) (ap-âˆ˜ fromSÂ¹ toSÂ¹ east) âŸ©
      (ap fromSÂ¹ (ap toSÂ¹ east))â»Â¹ âˆ™ east ï¼âŸ¨ ap (Î» - â†’ (ap fromSÂ¹ -)â»Â¹ âˆ™ east) app-toSÂ¹-east âŸ©
      east âˆ


S^1â‰…SÂ¹ : S^ 1 â‰… SÂ¹
S^1â‰…SÂ¹ = â‰…pf toSÂ¹ (Ivtbl fromSÂ¹ tofrom fromto)
```

Now we show that (base ï¼ base) â‰… â„¤
